import mongoose, { Schema } from 'mongoose';
import { IExam, IExamSection, IExamGradeAssignment } from '../types/index.js';

const examSectionSchema = new Schema<IExamSection>({
  name: {
    type: String,
    required: true,
  },
  description: {
    type: String,
  },
  marks: {
    type: Number,
    required: true,
    min: 0,
  },
});

const examGradeAssignmentSchema = new Schema<IExamGradeAssignment>({
  grade: {
    type: String,
    required: true,
  },
  teacherId: {
    type: Schema.Types.ObjectId,
    ref: 'Teacher',
    required: true,
  },
});

const examSchema = new Schema<IExam>({
  examId: {
    type: String,
    unique: true,
    required: false, // Will be auto-generated by pre-save hook
  },
  name: {
    type: String,
    required: [true, 'Exam name is required'],
    trim: true,
  },
  subject: {
    type: String,
    required: [true, 'Subject is required'],
  },
  subjectId: {
    type: Schema.Types.ObjectId,
    ref: 'Subject',
  },
  grades: [{
    type: String,
  }],
  classes: [{
    type: String,
  }],
  date: {
    type: Date,
    required: [true, 'Exam date is required'],
  },
  time: {
    type: String,
    required: [true, 'Exam time is required'],
  },
  startTime: {
    type: String,
  },
  duration: {
    type: String,
    required: [true, 'Duration is required'],
  },
  totalMarks: {
    type: Number,
    required: [true, 'Total marks is required'],
    min: 0,
  },
  passingMarks: {
    type: Number,
    min: 0,
  },
  description: {
    type: String,
  },
  sections: [examSectionSchema],
  gradeAssignments: [examGradeAssignmentSchema],
  status: {
    type: String,
    enum: ['Scheduled', 'In Progress', 'Completed', 'Cancelled'],
    default: 'Scheduled',
  },
}, {
  timestamps: true,
});

// Generate examId before saving
examSchema.pre('save', async function(next) {
  // Only generate if examId is not already set
  if (!this.examId) {
    try {
      // Find the highest existing examId number to avoid conflicts
      const ExamModel = mongoose.model('Exam');
      const examsWithId = await ExamModel.find({ 
         examId: { $exists: true, $ne: null, $nin: ['', null] }
      })
        .sort({ examId: -1 })
        .limit(1);
      
      let examIdCounter = 1;
      if (examsWithId.length > 0 && examsWithId[0].examId) {
        const lastIdMatch = String(examsWithId[0].examId).match(/\d+$/);
        if (lastIdMatch) {
          examIdCounter = parseInt(lastIdMatch[0]) + 1;
        }
      }
      
      // Generate examId and ensure uniqueness
      let attempts = 0;
      let generatedId = `EXM${String(examIdCounter).padStart(3, '0')}`;
      while (attempts < 10) {
        try {
          const exists = await ExamModel.findOne({ examId: generatedId });
          if (!exists) {
            this.examId = generatedId;
            break;
          }
        } catch (findError) {
          // If findOne fails, continue to next attempt
          console.warn('Error checking examId uniqueness:', findError);
        }
        examIdCounter++;
        generatedId = `EXM${String(examIdCounter).padStart(3, '0')}`;
        attempts++;
      }
      
      // Fallback if all attempts failed - use timestamp-based ID
      if (!this.examId) {
        const timestamp = Date.now().toString().slice(-8);
        this.examId = `EXM${timestamp}`;
      }
    } catch (error) {
      console.error('Error generating examId:', error);
      // Use timestamp-based fallback to ensure examId is always set
      // This prevents unique constraint issues
      if (!this.examId) {
        const timestamp = Date.now().toString().slice(-8);
        this.examId = `EXM${timestamp}`;
      }
      // Don't block the save - continue with the generated or fallback examId
    }
  }
  next();
});

const Exam = mongoose.model<IExam>('Exam', examSchema);

export default Exam;

